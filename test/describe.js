// Generated by CoffeeScript 1.10.0
(function() {
  var Q, times;

  Q = require('q');

  times = 0;

  describe(2, 'A retry suite', function() {
    it('works with a retried test not async', function() {
      times++;
      if (times % 2 !== 0) {
        throw new Error("not even");
      }
    });
    it('works with a retried test with a promise', function() {
      times++;
      return Q.fcall(function() {
        if (times % 2 !== 0) {
          throw new Error("not even");
        }
      });
    });
    return it('works with a retried test with callback', function(done) {
      times++;
      if (times % 2 !== 0) {
        return done(new Error("not even"));
      }
      return done();
    });
  });

  describe(2, 'Some retry suite with before', function() {
    var valueAll, valueEach;
    valueAll = valueEach = void 0;
    before(function() {
      return valueAll = true;
    });
    beforeEach(function() {
      return valueEach = true;
    });
    after(function() {
      return valueAll = false;
    });
    afterEach(function() {
      return valueEach = false;
    });
    it('works with a retried test not async', function() {
      valueEach.should.be["true"];
      valueAll.should.be["true"];
      times++;
      if (times % 2 !== 0) {
        throw new Error("not even");
      }
    });
    it('works with a retried test with a promise', function() {
      valueEach.should.be["true"];
      valueAll.should.be["true"];
      times++;
      return Q.fcall(function() {
        if (times % 2 !== 0) {
          throw new Error("not even");
        }
      });
    });
    return it('works with a retried test with callback', function(done) {
      valueEach.should.be["true"];
      valueAll.should.be["true"];
      times++;
      if (times % 2 !== 0) {
        return done(new Error("not even"));
      }
      return done();
    });
  });

  describe(2, 'A retry suite with tests with retry', function() {
    before(function() {
      return times = 0;
    });
    it(4, 'works with a retried test not async', function() {
      times++;
      if (times % 4 !== 0) {
        throw new Error("cant divide by 4");
      }
    });
    it(4, 'works with a retried test with a promise', function() {
      times++;
      return Q.fcall(function() {
        if (times % 4 !== 0) {
          throw new Error("cant divide by 4");
        }
      });
    });
    return it(4, 'works with a retried test with callback', function(done) {
      times++;
      if (times % 4 !== 0) {
        return done(new Error("cant divide by 4"));
      }
      return done();
    });
  });

  describe.skip(2, 'A skipped retry suite', function() {
    return it('a test that will not run', function() {});
  });

  describe.skip('A skipped non retry suite', function() {
    return it('another test that will not run', function() {});
  });

  describe(2, 'A retry suite with a sub suite', function() {
    describe('A sub suite without retry defined', function() {
      before(function() {
        return times = 0;
      });
      it('works with a retried test not async', function() {
        times++;
        if (times % 2 !== 0) {
          throw new Error("not even");
        }
      });
      it('works with a retried test with a promise', function() {
        times++;
        return Q.fcall(function() {
          if (times % 2 !== 0) {
            throw new Error("not even");
          }
        });
      });
      return it('works with a retried test with callback', function(done) {
        times++;
        if (times % 2 !== 0) {
          return done(new Error("not even"));
        }
        return done();
      });
    });
    return describe(3, 'A sub suite with retry redefined', function() {
      before(function() {
        return times = 0;
      });
      it('works with a retried test not async', function() {
        times++;
        if (times % 3 !== 0) {
          throw new Error("not divisible by 3");
        }
      });
      it('works with a retried test with a promise', function() {
        times++;
        return Q.fcall(function() {
          if (times % 3 !== 0) {
            throw new Error("not divisible by 3");
          }
        });
      });
      return it('works with a retried test with callback', function(done) {
        times++;
        if (times % 3 !== 0) {
          return done(new Error("not divisible by 3"));
        }
        return done();
      });
    });
  });

  describe('Using global default retry', function() {
    global.DEFAULT_RETRY = 2;
    before(function() {
      return times = 0;
    });
    return describe('inner suite (needed to apply global retry)', function() {
      it('works with a retried test not async', function() {
        times++;
        if (times % 2 !== 0) {
          throw new Error("not even");
        }
      });
      it('works with a retried test with a promise', function() {
        times++;
        return Q.fcall(function() {
          if (times % 2 !== 0) {
            throw new Error("not even");
          }
        });
      });
      return it('works with a retried test with callback', function(done) {
        times++;
        if (times % 2 !== 0) {
          return done(new Error("not even"));
        }
        return done();
      });
    });
  });

  delete global.DEFAULT_RETRY;

  describe('With global default retry but overriding it', function() {
    global.DEFAULT_RETRY = 2;
    before(function() {
      return times = 0;
    });
    describe(3, 'inner suite with specific retry (needed to apply global retry)', function() {
      it('works with a retried test not async', function() {
        times++;
        if (times % 3 !== 0) {
          throw new Error("not three");
        }
      });
      it('works with a retried test with a promise', function() {
        times++;
        return Q.fcall(function() {
          if (times % 3 !== 0) {
            throw new Error("not three");
          }
        });
      });
      return it('works with a retried test with callback', function(done) {
        times++;
        if (times % 3 !== 0) {
          return done(new Error("not three"));
        }
        return done();
      });
    });
    return describe('inner suite with tests that specify retry (needed to apply global retry)', function() {
      it(3, 'works with a retried test not async', function() {
        times++;
        if (times % 3 !== 0) {
          throw new Error("not three");
        }
      });
      it(3, 'works with a retried test with a promise', function() {
        times++;
        return Q.fcall(function() {
          if (times % 3 !== 0) {
            throw new Error("not three");
          }
        });
      });
      return it(3, 'works with a retried test with callback', function(done) {
        times++;
        if (times % 3 !== 0) {
          return done(new Error("not three"));
        }
        return done();
      });
    });
  });

  delete global.DEFAULT_RETRY;

}).call(this);
